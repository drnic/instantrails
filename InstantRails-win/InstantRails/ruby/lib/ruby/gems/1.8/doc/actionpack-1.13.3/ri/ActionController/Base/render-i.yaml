--- !ruby/object:RI::MethodDescription 
aliases: []

block_params: 
comment: 
- !ruby/struct:SM::Flow::P 
  body: Renders the content that will be returned to the browser as the response body.
- !ruby/struct:SM::Flow::H 
  level: 3
  text: Rendering an action
- !ruby/struct:SM::Flow::P 
  body: Action rendering is the most common form and the type used automatically by Action Controller when nothing else is specified. By default, actions are rendered within the current layout (if one exists).
- !ruby/struct:SM::Flow::VERB 
  body: "  # Renders the template for the action &quot;goal&quot; within the current controller\n  render :action =&gt; &quot;goal&quot;\n\n  # Renders the template for the action &quot;short_goal&quot; within the current controller,\n  # but without the current active layout\n  render :action =&gt; &quot;short_goal&quot;, :layout =&gt; false\n\n  # Renders the template for the action &quot;long_goal&quot; within the current controller,\n  # but with a custom layout\n  render :action =&gt; &quot;long_goal&quot;, :layout =&gt; &quot;spectacular&quot;\n"
- !ruby/struct:SM::Flow::P 
  body: "<em>Deprecation</em> <em>notice</em>: This used to have the signatures <tt>render_action(&quot;action&quot;, status = 200)</tt>, <tt>render_without_layout(&quot;controller/action&quot;, status = 200)</tt>, and <tt>render_with_layout(&quot;controller/action&quot;, status = 200, layout)</tt>."
- !ruby/struct:SM::Flow::H 
  level: 3
  text: Rendering partials
- !ruby/struct:SM::Flow::P 
  body: Partial rendering in a controller is most commonly used together with Ajax calls that only update one or a few elements on a page without reloading. Rendering of partials from the controller makes it possible to use the same partial template in both the full-page rendering (by calling it from within the template) and when sub-page updates happen (from the controller action responding to Ajax calls). By default, the current layout is not used.
- !ruby/struct:SM::Flow::VERB 
  body: "  # Renders the same partial with a local variable.\n  render :partial =&gt; &quot;person&quot;, :locals =&gt; { :name =&gt; &quot;david&quot; }\n\n  # Renders a collection of the same partial by making each element\n  # of @winners available through the local variable &quot;person&quot; as it\n  # builds the complete response.\n  render :partial =&gt; &quot;person&quot;, :collection =&gt; @winners\n\n  # Renders the same collection of partials, but also renders the\n  # person_divider partial between each person partial.\n  render :partial =&gt; &quot;person&quot;, :collection =&gt; @winners, :spacer_template =&gt; &quot;person_divider&quot;\n\n  # Renders a collection of partials located in a view subfolder\n  # outside of our current controller.  In this example we will be\n  # rendering app/views/shared/_note.r(html|xml)  Inside the partial\n  # each element of @new_notes is available as the local var &quot;note&quot;.\n  render :partial =&gt; &quot;shared/note&quot;, :collection =&gt; @new_notes\n\n  # Renders the partial with a status code of 500 (internal error).\n  render :partial =&gt; &quot;broken&quot;, :status =&gt; 500\n"
- !ruby/struct:SM::Flow::P 
  body: Note that the partial filename must also be a valid Ruby variable name, so e.g. 2005 and register-user are invalid.
- !ruby/struct:SM::Flow::P 
  body: "<em>Deprecation</em> <em>notice</em>: This used to have the signatures <tt>render_partial(partial_path = default_template_name, object = nil, local_assigns = {})</tt> and <tt>render_partial_collection(partial_name, collection, partial_spacer_template = nil, local_assigns = {})</tt>."
- !ruby/struct:SM::Flow::H 
  level: 3
  text: Rendering a template
- !ruby/struct:SM::Flow::P 
  body: Template rendering works just like action rendering except that it takes a path relative to the template root. The current layout is automatically applied.
- !ruby/struct:SM::Flow::VERB 
  body: "  # Renders the template located in [TEMPLATE_ROOT]/weblog/show.r(html|xml) (in Rails, app/views/weblog/show.rhtml)\n  render :template =&gt; &quot;weblog/show&quot;\n"
- !ruby/struct:SM::Flow::H 
  level: 3
  text: Rendering a file
- !ruby/struct:SM::Flow::P 
  body: File rendering works just like action rendering except that it takes a filesystem path. By default, the path is assumed to be absolute, and the current layout is not applied.
- !ruby/struct:SM::Flow::VERB 
  body: "  # Renders the template located at the absolute filesystem path\n  render :file =&gt; &quot;/path/to/some/template.rhtml&quot;\n  render :file =&gt; &quot;c:/path/to/some/template.rhtml&quot;\n\n  # Renders a template within the current layout, and with a 404 status code\n  render :file =&gt; &quot;/path/to/some/template.rhtml&quot;, :layout =&gt; true, :status =&gt; 404\n  render :file =&gt; &quot;c:/path/to/some/template.rhtml&quot;, :layout =&gt; true, :status =&gt; 404\n\n  # Renders a template relative to the template root and chooses the proper file extension\n  render :file =&gt; &quot;some/template&quot;, :use_full_path =&gt; true\n"
- !ruby/struct:SM::Flow::P 
  body: "<em>Deprecation</em> <em>notice</em>: This used to have the signature <tt>render_file(path, status = 200)</tt>"
- !ruby/struct:SM::Flow::H 
  level: 3
  text: Rendering text
- !ruby/struct:SM::Flow::P 
  body: Rendering of text is usually used for tests or for rendering prepared content, such as a cache. By default, text rendering is not done within the active layout.
- !ruby/struct:SM::Flow::VERB 
  body: "  # Renders the clear text &quot;hello world&quot; with status code 200\n  render :text =&gt; &quot;hello world!&quot;\n\n  # Renders the clear text &quot;Explosion!&quot;  with status code 500\n  render :text =&gt; &quot;Explosion!&quot;, :status =&gt; 500\n\n  # Renders the clear text &quot;Hi there!&quot; within the current active layout (if one exists)\n  render :text =&gt; &quot;Explosion!&quot;, :layout =&gt; true\n\n  # Renders the clear text &quot;Hi there!&quot; within the layout\n  # placed in &quot;app/views/layouts/special.r(html|xml)&quot;\n  render :text =&gt; &quot;Explosion!&quot;, :layout =&gt; &quot;special&quot;\n"
- !ruby/struct:SM::Flow::P 
  body: The :text option can also accept a Proc object, which can be used to manually control the page generation. This should generally be avoided, as it violates the separation between code and content, and because almost everything that can be done with this method can also be done more cleanly using one of the other rendering methods, most notably templates.
- !ruby/struct:SM::Flow::VERB 
  body: "  # Renders &quot;Hello from code!&quot;\n  render :text =&gt; proc { |response, output| output.write(&quot;Hello from code!&quot;) }\n"
- !ruby/struct:SM::Flow::P 
  body: "<em>Deprecation</em> <em>notice</em>: This used to have the signature <tt>render_text(&quot;text&quot;, status = 200)</tt>"
- !ruby/struct:SM::Flow::H 
  level: 3
  text: Rendering JSON
- !ruby/struct:SM::Flow::P 
  body: Rendering JSON sets the content type to text/x-json and optionally wraps the JSON in a callback. It is expected that the response will be eval'd for use as a data structure.
- !ruby/struct:SM::Flow::VERB 
  body: "  # Renders '{name: &quot;David&quot;}'\n  render :json =&gt; {:name =&gt; &quot;David&quot;}.to_json\n"
- !ruby/struct:SM::Flow::P 
  body: Sometimes the result isn't handled directly by a script (such as when the request comes from a SCRIPT tag), so the callback option is provided for these cases.
- !ruby/struct:SM::Flow::VERB 
  body: "  # Renders 'show({name: &quot;David&quot;})'\n  render :json =&gt; {:name =&gt; &quot;David&quot;}.to_json, :callback =&gt; 'show'\n"
- !ruby/struct:SM::Flow::H 
  level: 3
  text: Rendering an inline template
- !ruby/struct:SM::Flow::P 
  body: Rendering of an inline template works as a cross between text and action rendering where the source for the template is supplied inline, like text, but its interpreted with ERb or Builder, like action. By default, ERb is used for rendering and the current layout is not used.
- !ruby/struct:SM::Flow::VERB 
  body: "  # Renders &quot;hello, hello, hello, again&quot;\n  render :inline =&gt; &quot;&lt;%= 'hello, ' * 3 + 'again' %&gt;&quot;\n\n  # Renders &quot;&lt;p&gt;Good seeing you!&lt;/p&gt;&quot; using Builder\n  render :inline =&gt; &quot;xml.p { 'Good seeing you!' }&quot;, :type =&gt; :rxml\n\n  # Renders &quot;hello david&quot;\n  render :inline =&gt; &quot;&lt;%= 'hello ' + name %&gt;&quot;, :locals =&gt; { :name =&gt; &quot;david&quot; }\n"
- !ruby/struct:SM::Flow::P 
  body: "<em>Deprecation</em> <em>notice</em>: This used to have the signature <tt>render_template(template, status = 200, type = :rhtml)</tt>"
- !ruby/struct:SM::Flow::H 
  level: 3
  text: Rendering inline JavaScriptGenerator page updates
- !ruby/struct:SM::Flow::P 
  body: In addition to rendering JavaScriptGenerator page updates with Ajax in RJS templates (see ActionView::Base for details), you can also pass the <tt>:update</tt> parameter to <tt>render</tt>, along with a block, to render page updates inline.
- !ruby/struct:SM::Flow::VERB 
  body: "  render :update do |page|\n    page.replace_html  'user_list', :partial =&gt; 'user', :collection =&gt; @users\n    page.visual_effect :highlight, 'user_list'\n  end\n"
- !ruby/struct:SM::Flow::H 
  level: 3
  text: Rendering nothing
- !ruby/struct:SM::Flow::P 
  body: Rendering nothing is often convenient in combination with Ajax calls that perform their effect client-side or when you just want to communicate a status code. Due to a bug in Safari, nothing actually means a single space.
- !ruby/struct:SM::Flow::VERB 
  body: "  # Renders an empty response with status code 200\n  render :nothing =&gt; true\n\n  # Renders an empty response with status code 401 (access denied)\n  render :nothing =&gt; true, :status =&gt; 401\n"
full_name: ActionController::Base#render
is_singleton: false
name: render
params: (options = nil, deprecated_status = nil, &block)
visibility: protected
