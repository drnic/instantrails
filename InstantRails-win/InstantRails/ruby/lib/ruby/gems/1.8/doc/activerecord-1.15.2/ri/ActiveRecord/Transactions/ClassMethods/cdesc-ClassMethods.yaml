--- !ruby/object:RI::ClassDescription 
attributes: []

class_methods: []

comment: 
- !ruby/struct:SM::Flow::P 
  body: "Transactions are protective blocks where SQL statements are only permanent if they can all succeed as one atomic action. The classic example is a transfer between two accounts where you can only have a deposit if the withdrawal succeeded and vice versa. Transactions enforce the integrity of the database and guard the data against program errors or database break-downs. So basically you should use transaction blocks whenever you have a number of statements that must be executed together or not at all. Example:"
- !ruby/struct:SM::Flow::VERB 
  body: "  transaction do\n    david.withdrawal(100)\n    mary.deposit(100)\n  end\n"
- !ruby/struct:SM::Flow::P 
  body: This example will only take money from David and give to Mary if neither <tt>withdrawal</tt> nor <tt>deposit</tt> raises an exception. Exceptions will force a ROLLBACK that returns the database to the state before the transaction was begun. Be aware, though, that the objects by default will <em>not</em> have their instance data returned to their pre-transactional state.
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Transactions are not distributed across database connections
- !ruby/struct:SM::Flow::P 
  body: "A transaction acts on a single database connection. If you have multiple class-specific databases, the transaction will not protect interaction among them. One workaround is to begin a transaction on each class whose models you alter:"
- !ruby/struct:SM::Flow::VERB 
  body: "  Student.transaction do\n    Course.transaction do\n      course.enroll(student)\n      student.units += course.units\n    end\n  end\n"
- !ruby/struct:SM::Flow::P 
  body: This is a poor solution, but full distributed transactions are beyond the scope of Active Record.
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Save and destroy are automatically wrapped in a transaction
- !ruby/struct:SM::Flow::P 
  body: Both Base#save and Base#destroy come wrapped in a transaction that ensures that whatever you do in validations or callbacks will happen under the protected cover of a transaction. So you can use validations to check for values that the transaction depend on or you can raise exceptions in the callbacks to rollback.
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Object-level transactions (deprecated)
- !ruby/struct:SM::Flow::P 
  body: "You can enable object-level transactions for Active Record objects, though. You do this by naming each of the Active Records that you want to enable object-level transactions for, like this:"
- !ruby/struct:SM::Flow::VERB 
  body: "  Account.transaction(david, mary) do\n    david.withdrawal(100)\n    mary.deposit(100)\n  end\n"
- !ruby/struct:SM::Flow::P 
  body: If the transaction fails, David and Mary will be returned to their pre-transactional state. No money will have changed hands in neither object nor database.
- !ruby/struct:SM::Flow::P 
  body: However, useful state such as validation errors are also rolled back, limiting the usefulness of this feature. As such it is deprecated in Rails 1.2 and will be removed in the next release. Install the object_transactions plugin if you wish to continue using it.
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Exception handling
- !ruby/struct:SM::Flow::P 
  body: Also have in mind that exceptions thrown within a transaction block will be propagated (after triggering the ROLLBACK), so you should be ready to catch those in your application code.
- !ruby/struct:SM::Flow::P 
  body: "Tribute: Object-level transactions are implemented by Transaction::Simple by Austin Ziegler."
constants: []

full_name: ActiveRecord::Transactions::ClassMethods
includes: []

instance_methods: 
- !ruby/object:RI::MethodSummary 
  name: transaction
name: ClassMethods
superclass: 
